# 了解集合层次结构

## 避免在集合层次结构中迷失方向

集合框架被划分为多个接口和类的层次结构。首先需要理解的是集合接口层次结构。

![集合接口层次结构图](./image/01_interfaces-hierarchy.png)

## 可迭代接口

这个层次结构的第一个接口是`Iterable`接口，实际上它不是集合框架的一部分。尽管如此，在这里提及它是值得的，因为它是`Collection`接口的超接口，因此也是这个层次结构中所有接口的超接口。

`Iterable`接口是Java SE 5（2004年）新增的。实现`Iterable`的对象是你可以迭代的对象。它是与Java SE 5中的_for each_代码模式一起添加的。

你可能已经熟悉了以下方式，用于迭代`Collection`的元素：

```java
Collection<String> collection = ...;

for (String element : collection) {
    // 对element进行操作
}
```

你可能已经知道，你可以使用这种模式迭代任何集合，或者任何数组。事实上，任何`Iterable`的实例都可以在这里使用。

实现`Iterable`接口非常简单：你所需要做的是提供一个`Iterator`接口的实例，你将在下面看到。

## 使用集合接口在容器中存储元素

所有其他接口都是关于在容器中存储元素的。

`List`和`Set`两个接口都共享一个公共行为，该行为由`Collection`接口建模。`Collection`接口对元素容器上的几种操作进行了建模。（尚未深入技术细节！）这里是你可以对`Collection`做的：

- 添加或删除元素；
- 测试给定元素的存在；
- 询问包含的元素数量，或者这个集合是否为空；
- 清空内容。

由于一个`Collection`是一组元素，集合接口还定义了一组操作：

- 测试一个集合是否包含在另一个集合中；
- 联合；
- 交集；
- 补集。

最后，`Collection`接口还建模了不同的访问其元素的方式：

- 你可以通过使用迭代器迭代集合的元素；
- 你可以在这些元素上创建一个可以并行的流。

当然，所有这些操作也适用于`List`和`Set`。那么，一个普通的`Collection`实例和一个`Set`实例或一个`List`实例之间的区别是什么呢？

## 使用列表扩展集合

`List`元素和`Collection`元素之间的区别在于，`List`记住了其元素添加的顺序。

第一个后果是，如果你迭代列表的元素，你将得到的第一个元素是第一个添加的。然后你会得到第二个，依此类推，直到所有元素都被查看。所以你迭代元素的顺序总是相同的，它由这些元素添加的顺序决定。你不能保证一个普通的`Collection`或一个`Set`有这个保证。

> 实际上，集合框架提供的某些`Set`实现总是以相同的顺序迭代元素。这是一个偶然的效果，你的代码不应该依赖这种行为。

第二个后果可能不如第一个明显，即列表的元素有索引。查询集合的“第一个”元素没有意义。查询列表的“第一个”元素是有意义的，因为列表确实记住了。

这些索引是如何处理的呢？嗯，再一次，这是实现的责任。接口的首要角色是指定行为，而不是告诉实现应该如何实现。

正如你将看到的，`List`接口在`Collection`接口的基础上增加了新操作。由于列表的元素有索引，你可以使用该索引进行以下操作：

- 获取或删除特定索引处的元素；
- 在特定位置插入或替换元素；
- 获取两个索引之间的元素范围。

## 使用集合扩展集合

`Set`元素和`Collection`元素之间的区别在于，`Set`中不能有重复项。你可以在`Collection`中拥有多个相等的同一类实例，甚至同一个实例多次。这在`Set`中是不允许的。如何执行这个由实现负责，你将在本教程后面看到。

这种行为的一个后果是，向`Set`添加一个元素可能会失败。

然后你可能会问自己：我可以有一个防止重复的容器，并且其中的元素有索引吗？答案并不那么简单。集合框架给你提供了一个`Set`实现，你将始终以相同的顺序迭代元素，但这些元素没有索引，所以这个类没有实现`List`。

这种行为上的差异并没有给`Set`接口带来任何新操作。

## 使用SortedSet和NavigableSet对集合元素进行排序

`Set`接口本身有两个扩展：`SortedSet`和`NavigableSet`。

`SortedSet`接口保持其元素按升序排序。同样，如何执行这一点是实现的责任，你将在稍后看到。

为了能够对它们进行排序，`SortedSet`需要比较你的元素。它如何实现呢？嗯，在Java语言中定义了两种标准机制：

- 你的元素可以实现`Comparable`接口，并提供`compareTo()`方法
- 你给`SortedSet`一个`Comparator`，以便它可以比较它们。

即使你的元素是`Comparable`的，当你构建`SortedSet`时，你仍然可以提供一个`Comparator`。这可能很有用，如果你需要以不同于`compareTo()`方法实现的顺序排序你的元素。

> 排序和排序之间有什么区别？`List`保持其元素按添加顺序，而`SortedSet`保持它们排序。对元素进行排序意味着在遍历集合时你得到的第一个元素将是最低的，就给定的比较逻辑而言。对元素进行排序意味着你添加到列表中的顺序将在整个列表的生命周期中保持。所以你在遍历列表时得到的第一个元素是你首先添加到它的第一个。

`SortedSet`在`Set`的基础上增加了几个操作。以下是你可以使用`SortedSet`进行的操作：

- 你可以获取集合中的最低元素和最高元素
- 你可以提取所有小于或大于给定元素的所有元素的`headSet`和`tailSet`。

遍历`SortedSet`的元素将从最低元素到最高元素进行。

`NavigableSet`没有改变`SortedSet`的行为。它在`SortedSet`的基础上增加了几个非常有用的操作，其中包括按降序迭代元素的可能性。你将在稍后看到更多细节。


