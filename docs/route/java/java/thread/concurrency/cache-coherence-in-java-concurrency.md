# Java并发中的CPU缓存一致性

在这个Java并发教程系列中的其他一些教程里，你可能已经读到，或者在视频中听到我说，当一个Java线程写入一个volatile变量，或者退出一个同步块时，这会将线程可见的所有变量从CPU缓存刷新到主内存。
实际上并非如此。

实际发生的是，所有线程可见的存储在CPU寄存器中的变量将被刷新到主RAM（主内存）。在到达主RAM的路上，这些变量可能被存储在CPU缓存中。然后，CPU/主板使用其缓存一致性方法确保所有其他CPU缓存都能看到第一个CPU缓存中的变量。

硬件甚至可能选择不将变量一直刷新到主内存，而只是保留在CPU缓存中 - 直到存储变量的CPU缓存需要其他数据。那时，CPU缓存然后可以被刷新到主内存。然而，对于运行在CPU上的代码来说，这是不可见的。只要它从任何给定的内存地址获得请求的数据，返回的数据是仅存在于CPU缓存中，还是也存在于主RAM中，都没有关系。

你不必担心CPU缓存一致性是如何工作的。
当然，CPU缓存一致性会带来一点性能损失，但这比将变量一直写入主内存并重新加载到其他CPU缓存要好。

下图说明了我上面所说的。左边的红色虚线箭头代表了我其他教程中的错误陈述 - 变量从CPU缓存刷新到主RAM。右边的箭头代表了实际发生的情况 - 变量从CPU寄存器刷新到CPU缓存。

![CPU缓存与Java并发图示](./image/cpu-cache-coherence-and-java-concurrency-1.png)


