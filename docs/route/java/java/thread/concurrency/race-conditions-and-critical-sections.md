# 竞态条件和临界区

竞态条件是可能发生在临界区内的并发问题。临界区是多线程执行的代码段，线程的执行顺序对临界区并发执行的结果有影响。

当多个线程执行临界区的结果可能因线程的执行顺序而有所不同时，我们说临界区包含竞态条件。竞态条件这个术语来源于线程在临界区内竞争的隐喻，以及这种竞争的结果影响执行临界区的结果。

这可能听起来有点复杂，所以我将在以下部分更详细地阐述竞态条件和临界区。

## 两种类型的竞态条件

当两个或更多的线程根据以下两种模式之一读取和写入同一个变量时，可能会发生竞态条件：

- 读-修改-写
- 检查-然后-执行

读-修改-写模式意味着两个或更多的线程首先读取给定变量，然后修改其值并将其写回变量。为了引起问题，新值必须以某种方式依赖于先前的值。可能会发生的问题是，如果两个线程读取值（到CPU寄存器），然后修改值（在CPU寄存器中），然后写回值。稍后将更详细地解释这种情况。

检查-然后-执行模式意味着两个或更多的线程检查给定条件，例如Map是否包含给定值，然后根据该信息采取行动，例如从Map中取出值。如果两个线程同时检查Map中的给定值 - 看到值存在 - 然后两个线程都尝试取出（删除）该值，可能会发生问题。然而，只有一个线程实际上可以取值。另一个线程将得到一个null值。如果使用队列而不是Map，也可能发生这种情况。

## 读-修改-写临界区

如上所述，读-修改-写临界区可能导致竞态条件。在本节中，我将更仔细地看看为什么会这样。

以下是一个可能在多个线程同时执行时失败的读-修改-写临界区Java代码示例：

```java
public class Counter {
    protected long count = 0;

    public void add(long value){
        this.count = this.count + value;
    }
}
```

想象一下，如果两个线程A和B正在对`Counter`类的同一个实例执行`add`方法。我们无法知道操作系统何时在两个线程之间切换。`add()`方法中的代码不是由Java虚拟机作为单个原子指令执行的。而是作为一组较小的指令执行，类似于这样：

1. 从内存中读取this.count到寄存器。
2. 向寄存器添加值。
3. 将寄存器写回内存。

观察以下线程A和B混合执行时会发生什么：

``` 
   A: 将this.count读入寄存器（0）
   B: 将this.count读入寄存器（0）
   B: 向寄存器添加值2
   B: 将寄存器值（2）写回内存。this.count现在等于2
   A: 向寄存器添加值3
   A: 将寄存器值（3）写回内存。this.count现在等于3
```

两个线程想要将值2和3加到计数器上。因此，在两个线程完成执行后，值应该是5。然而，由于两个线程的执行是交错的，结果最终会有所不同。

在上面列出的执行序列示例中，两个线程都从内存中读取值0。然后它们将各自的值2和3加到该值上，并将结果写回内存。`this.count`中留下的值不是5，而是最后一个写入其值的线程写的值。在上面的案例中是线程A，但也可能是线程B。

### 读-修改-写临界区中的竞态条件

前面示例中的`add()`方法中的代码包含一个临界区。当多个线程执行这个临界区时，会发生竞态条件。

更正式地说，两个线程竞争同一资源，访问资源的顺序很重要的情况称为竞态条件。导致竞态条件的代码段称为临界区。

## 检查-然后-执行临界区

如上所述，检查-然后-执行临界区也可能导致竞态条件。如果两个线程检查相同的条件，然后以改变条件的方式采取行动，可能会导致竞态条件。如果两个线程同时检查条件，然后一个线程继续改变条件，这可能会导致另一个线程在该条件下错误地采取行动。

为了说明检查-然后-执行临界区如何导致竞态条件，请看以下示例：

```java
public class CheckThenActExample {

    public void checkThenAct(Map<String, String> sharedMap) {
        if(sharedMap.containsKey("key")){
            String val = sharedMap.remove("key");
            if(val == null) {
                System.out.println("Value for 'key' was null");
            }
        } else {
            sharedMap.put("key", "value");
        }
    }
}
```

如果两个或更多的线程对同一个CheckThenActExample对象调用`checkThenAct()`方法，那么两个或更多的线程可能会同时执行if语句，评估`sharedMap.containsKey("key")`为`true`，并因此进入if语句的代码块。在那里，多个线程可能尝试删除存储在键"key"下的键值对，但只有一个线程实际上能够做到。其他的将得到一个`null`值，因为另一个线程已经删除了键值对。

## 预防竞态条件

为了防止竞态条件的发生，你必须确保临界区作为一个原子指令执行。这意味着一旦一个线程开始执行它，其他线程在第一个线程离开临界区之前都不能执行它。

可以通过在临界区进行适当的线程同步来避免竞态条件。可以使用Java代码的同步块来实现线程同步。也可以使用其他同步构造，如锁或像java.util.concurrent.atomic.AtomicInteger这样的原子变量来实现线程同步。

## 临界区吞吐量

对于较小的临界区，将整个临界区作为一个同步块可能有效。但是，对于较大的临界区，将临界区细分为较小的临界区可能更有益，以允许多个线程分别执行每个较小的临界区。这可以减少对共享资源的争用，从而提高总临界区的吞吐量。

以下是一个非常简化的Java代码示例，以展示我的意思：

```java
public class TwoSums {

    private int sum1 = 0;
    private int sum2 = 0;

    public void add(int val1, int val2){
        synchronized(this){
            this.sum1 += val1;
            this.sum2 += val2;
        }
    }
}
```

请注意，`add()`方法向两个不同的求和成员变量添加值。为了防止竞态条件，求和是在Java同步块内执行的。有了这种实现，一次只有一个线程可以同时执行求和。

然而，由于两个求和变量彼此独立，你可以将它们的求和拆分为两个单独的同步块，如下所示：

```java
public class TwoSums {

    private int sum1 = 0;
    private int sum2 = 0;

    private Integer sum1Lock = new Integer(1);
    private Integer sum2Lock = new Integer(2);

    public void add(int val1, int val2){
        synchronized(this.sum1Lock){
            this.sum1 += val1;
        }
        synchronized(this.sum2Lock){
            this.sum2 += val2;
        }
    }
}
```

现在，两个线程可以同时执行`add()`方法。一个线程在第一个同步块内，另一个线程在第二个同步块内。两个同步块分别同步在不同的对象上，因此两个不同的线程可以独立执行这两个块。这样，线程们就不必为了执行`add()`方法而长时间等待彼此。

当然，这个例子非常简单。在现实生活中的共享资源中，细分临界区可能会更加复杂，并需要更多地分析执行顺序的可能性。


