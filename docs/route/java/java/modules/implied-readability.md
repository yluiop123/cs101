# 使用 `requires transitive` 的隐式可读性 

模块系统对访问其他模块中的代码有严格的规则，其中之一是访问模块必须对被访问的模块进行**读取**。
建立可读性的最常见方式是让一个模块要求另一个模块，但这不是唯一的方式。
如果一个模块在其自己的API中使用另一个模块的类型，那么每个使用第一个模块的外部实体也将被迫要求第二个模块。
除非第一个模块对第二个模块使用 `requires transitive`，这意味着对任何读取第一个模块的模块隐式地读取第二个模块。
这有点令人困惑，但几分钟后你就会明白了。

**注意**：
为了充分利用本文，你需要了解模块系统基础知识。

## 隐式可读性

在通常情况下，一个模块内部使用依赖项，而外部世界并不了解它。
以 `java.prefs` 为例，它 `requires` `java.xml`：
它需要XML解析功能，但它自己的API既不接受也不返回来自 `java.xml` 包的类型。

但还有另一种情况，依赖项不完全是内部的，而是存在于模块之间的边界上。
在这种情况下，一个模块依赖于另一个模块，并在其自己的公共API中公开来自被依赖模块的类型。
一个很好的例子是 `java.sql`。
它也使用 `java.xml`，但与 `java.prefs` 不同的是，不仅仅是内部使用 - 公共类 `java.sql.SQLXML` 映射SQL XML类型，因此在其自己的API中使用来自 `java.xml` 的类型。
类似地，`java.sql` 的 `Driver` 有一个方法 `getParentLogger()`，返回一个 `Logger`，这是来自 `java.logging` 模块的类型。

在这种情况下，想要调用该模块（例如 `java.sql`）的代码可能需要使用被依赖模块（例如 `java.xml`、`java.logging`）中的类型。
但如果它没有同时读取被依赖的模块，它就无法做到这一点。
因此，为了使该模块至少可用，客户端也必须显式地依赖第二个模块。
识别和手动解决这些隐藏的依赖项将是一项乏味且容易出错的任务。

这就是隐式可读性的用武之地。
它扩展了模块声明，使得一个模块可以将其依赖的模块的可读性授予任何依赖于它的模块。
这种隐式可读性通过在 `requires` 子句中包含 `transitive` 修饰符来表达。

这就是为什么 `java.sql` 的模块声明如下所示：

```java
module java.sql {
    requires transitive java.logging;
    requires transitive java.transaction.xa;
    requires transitive java.xml;

    exports java.sql;
    exports javax.sql;

    uses java.sql.Driver;
}
```

这意味着任何读取 `java.sql`（通常是通过要求它）的模块也将自动读取 `java.logging`、`java.transaction.xa` 和 `java.xml`。

## 何时依赖隐式可读性

模块系统的最初解释者包括何时使用隐式可读性的明确建议：

> 一般来说，如果一个模块导出包含其签名引用第二个模块包中类型的包，则第一个模块的声明应该包括对第二个模块的 `requires transitive` 依赖。
> 这将确保依赖于第一个模块的其他模块将自动能够读取第二个模块，因此能够访问该模块导出包中的所有类型。

但你应该将此建议应用到多远？
回想一下 `java.sql` 的例子，使用它的模块还需要 `java.logging` 吗？
从技术上讲，这样的声明是不需要的，可能看起来是多余的。

要回答这个问题，我们需要看看虚构模块如何使用 `java.logging`。
它可能只需要读取它，以便能够调用 `Driver.getParentLogger()`，例如，为了更改日志记录器的日志级别，而不需要更多。
在这种情况下，你的代码与 `java.logging` 的交云发生在它与 `java.sql` 中的 `Driver` 交云的直接附近。
在上面我们称之为两个模块之间的边界。

或者你的模块可能实际上在其自己的代码中使用了日志记录。
然后，来自 `java.logging` 的类型出现在许多地方，与 `Driver` 无关，并且不再能被认为是局限于你的模块和 `java.sql` 之间的边界。

建议仅在模块的类型仅用于与 `requires transitive` 它的模块（例如 `java.sql`）的边界时，依赖模块（例如 `java.logging`）的隐式可读性。
否则，即使不是严格需要的，也应该明确要求。
这种方法澄清了系统的结构，也为各种重构未来的模块声明提供了保障。

