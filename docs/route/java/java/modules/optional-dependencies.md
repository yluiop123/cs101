# 使用 `requires static` 的可选依赖 

模块系统对依赖有强烈的看法：
默认情况下，它们需要被显式声明（以便可访问），然后它们需要在编译和运行时都存在。
但这与可选依赖不相符，在可选依赖中，代码可能会使用在运行时不一定存在的构件。
`requires static` 指令通过要求在编译时存在但在运行时可以不存在来解决这个问题。

**注意**：
要充分利用本文，你需要了解模块系统基础知识。

## 使用 `requires static` 的可选依赖

当一个模块需要针对另一个模块中的类型进行编译，但不希望在运行时依赖于它时，它可以使用 `requires static` 指令。
如果模块 A `requires static` 模块 B，模块系统在编译和运行时的行为如下：

- 在编译时，必须存在 B（否则会出现错误）并且 A 可以读取 B。
  （这是依赖的常见行为。）
- 在运行时，B 可能不存在，这既不会导致错误也不会有警告。
  如果它存在，它会被 A 读取。

确切地说，如何处理存在性并不简单，但在讨论之前让我们先看一个例子。
在 JDK 中，没有依赖是可选的，所以我们需要自己举例。

让我们设想一个应用程序，它在没有额外专有库的情况下已经很好地解决了它的业务案例，但在有该库的情况下可以做得更好。
在这个例子中，我们称应用程序的模块为 `com.example.app`，库为 `com.sample.solver`。
我们还假设集成的代码是这样编写的，`com.example.app` 引用了 `com.sample.solver` 中的类型，这意味着 `app` 需要被编译针对 `solver`，这反过来意味着 `app` 必须要求 `solver`：

但是，正如我们讨论模块解析时所探索的，这意味着如果 `com.sample.solver` 缺失，模块系统将在运行时抛出一个错误 - 显然，这个依赖不是可选的。
让我们改用 `requires static`：

对于 `com.example.app` 的编译，需要 `com.sample.solver` 并且必须存在，这意味着它的类型可以自由使用。
在运行时，它可能缺失，这引发了我们接下来将要回答的两个问题：

- 在什么情况下可选依赖项会存在？
- 我们如何针对可选依赖项编写代码？

## 可选依赖项的解析

模块解析是从根模块开始，通过解析 `requires` 指令构建模块图的过程。
当解析一个模块时，它所要求的所有模块都必须在运行时或模块路径上找到，并且如果它们存在，它们会被添加到模块图中；否则就会发生错误。
（请注意，在解析期间没有进入模块图的那些模块，在后续的编译或执行中也不可用。）
在编译时，模块解析对可选依赖的处理就像对普通依赖一样。
但在运行时，它们大多被忽略。

当模块系统遇到 `requires static` 指令时，它不会尝试满足它，这意味着它甚至不会检查是否可以找到引用的模块。
因此，即使模块在模块路径上（或 JDK 中），仅仅因为一个可选依赖，它也不会被添加到模块图。
它只有在以其他方式进入模块图的情况下才会被加入，例如它也是正在解析的某个其他模块的常规依赖，或者因为它使用了命令行标志 `--add-modules` 被显式添加。
在那种情况下，模块系统将从要求模式到可选依赖添加一个可读性边。

换句话说，除非可选依赖以其他方式进入模块图，否则会被忽略，在这种情况下，产生的模块图就像它是一个非可选依赖一样。

## 针对可选依赖编写代码

针对可选依赖编写代码需要更多的思考。
一般来说，当前正在执行的代码引用一个类型时，Java 运行时会检查它是否已经加载。
如果没有，它告诉类加载器这样做，如果失败了，结果是 `NoClassDefFoundError`，这通常会使应用程序崩溃，或者至少退出正在执行的逻辑块。

这是 JAR 地狱著名的问题，并且模块系统希望通过在启动应用程序时检查声明的依赖来克服它。
但使用 `requires static` 我们选择退出那个检查，这意味着我们最终可能会遇到 `NoClassDefFoundError`。

### 检查模块存在性

为了避免这种情况，我们可以查询模块系统来检查模块的存在性：

调用者需要将自己传递给方法，以便它可以确定要查询的正确层以查询所需的模块。

### 已建立的依赖项

尽管可能不总是需要显式检查模块的存在性。
想象一个库 `com.example.lib`，它帮助使用各种现有 API，其中包括 `java.sql` 中的 JDBC API。
那么，假设不使用 JDBC 的代码就不使用该库的该部分是有意义的。
换言之，我们可以假设库的 JDBC 部分只会被已经使用 JDBC 的代码调用，这意味着 `java.sql` 必须是模块图的一部分。

一般来说，如果使用可选依赖的代码只会被依赖于相同依赖的代码调用，可以假定它的存在，不需要检查。

