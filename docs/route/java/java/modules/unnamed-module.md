# 代码在类路径上 - 无名模块

模块系统希望一切都是模块，以便它可以统一应用其规则，但同时，创建模块并不是强制性的（并且使其成为强制性的将不符合向后兼容性）。
调和这两个看似矛盾的要求的机制是无名模块。
它包含类路径上的所有类，并对其应用一些特殊规则，但一旦完成，它的运作就像任何其他模块一样。

这意味着如果你从类路径启动你的代码，无名模块将起作用。
除非你的应用程序相当小，否则它可能需要逐步模块化，这涉及到混合使用JAR和模块，类路径和模块路径。
这使得理解模块系统的“类路径模式”如何工作变得很重要。

**注意**：
为了充分利用本文，你需要了解模块系统基础知识。

## 无名模块

无名模块包含所有“非模块类”，这些类是：

- 在编译时，如果不包含模块描述符，则正在编译的类
- 在编译和运行时，从类路径加载的所有类

所有模块都有三个中心属性，这对无名模块也是如此：

- 名称：无名模块没有名称（说得通，对吧？），这意味着没有其他模块可以在其声明中提及它（例如要求它）
- 依赖项：无名模块读取进入图的所有其他模块
- 导出：无名模块导出其所有包，并为反射打开它们

与无名模块形成对比的是，所有其他模块都被称为 _命名_ 模块。
`META-INF/services` 中提供的服务对 `ServiceLoader` 可用。

虽然概念并不完全直接，但无名模块的概念是有意义的。
这里你有有序的模块图，而在那边，稍微有点距离的地方，你有类路径的混乱，被归入它自己的自由模块，具有一些特殊属性。

## 类路径的混乱

无名模块的主要目标是捕获类路径内容并使其在模块系统中工作。
由于类路径上的JAR之间从未有过任何边界，所以现在建立它们是没有意义的，因此整个类路径有一个单一的无名模块。
在它内部，就像在类路径上一样，所有公共类都可以相互访问，包可以跨JAR分割。

无名模块的独特角色及其对向后兼容性的关注赋予它一些特殊属性。
其中一个是Java 9到16中对强封装API的间歇性访问。
另一个是它不受许多应用于命名模块的检查的影响。
因此，它与其他模块之间的包分割不会被发现，类路径部分也不可用。
（这意味着，如果同一个包也存在于命名模块中，实际上类路径上存在缺失类的错误的类可能会出错。）

有点违反直觉且容易出错的一个细节是，究竟什么构成了无名模块。
似乎很明显，模块化JAR变成了模块，因此普通JAR进入无名模块，对吧？
但事实并非如此，无名模块负责 _类路径上的所有JAR_ ，无论是否模块化。
因此，模块化JAR不一定要作为模块加载！
所以，如果一个库开始提供模块化JAR，其用户绝不会被迫将它们作为模块使用。
他们可以将其留在类路径上，在那里它们的代码被捆绑到无名模块中。
这允许生态系统几乎独立于彼此进行模块化。

为了尝试这个，你可以将以下两行代码放入你打包为模块化JAR的类中：

```java
String moduleName = this.getClass().getModule().getName();
System.out.println("Module name: " + moduleName);
```

当从类路径启动时，输出是 `Module name: null`，表明该类最终进入了无名模块。
当从模块路径启动时，你会得到预期的 `Module name: $MODULE`，其中 `$MODULE` 是你给模块的名称。

## 无名模块的模块解析

无名模块与模块图其余部分关系的一个重要方面是它可以读取的其他模块。
如上所述，这些是进入图的所有模块。
但哪些模块是那个？
记住从模块系统基础知识中，模块解析通过从根模块（特别是初始模块）开始，然后迭代添加它们所有直接和传递依赖项来构建模块图。
如果编译中的代码或应用程序的主方法位于无名模块中，就像从类路径启动应用程序时的情况一样，这将如何工作呢？
毕竟，普通JAR不表达任何依赖项。

如果初始模块是无名的，模块解析从一组预定义的根模块开始。
作为经验法则，这些是在运行时中发现的模块，但实际规则有点更详细：

- 成为根的 _java.\*_ 模块的确切集合取决于 _java.se_ 模块（即代表整个Java SE API的模块；它在完整的JRE映像中存在，但可能在用 `jlink` 创建的自定义运行时映像中不存在）的存在：
  - 如果 _java.se_ 可观察到，它就成为根。
  - 如果没有，每个至少导出一个未限定包的 _java.\*_ 模块都成为根。
- 除了 _java.\*_ 模块，运行时中的每个其他模块（不是孵化模块并且至少导出一个未限定包）都成为根模块。
  这对于 _jdk.\*_ 模块特别相关。
- 用 `--add-modules` 列出的模块总是根模块。

请注意，随着无名模块作为初始模块，根模块集合总是运行时映像中包含的模块的子集。
除非明确用 `--add-modules` 添加，否则模块路径上的模块永远不会被解析。
如果你手工制作模块路径以包含你恰好需要的模块，你可能想用 `--add-modules ALL-MODULE-PATH` 将它们全部添加，如本文所解释的。

## 依赖无名模块

模块系统的主要目标之一是可靠的配置：
模块必须表达其依赖项，模块系统必须能够保证它们的存在。
我们讨论了具有模块描述符的显式模块，但如果我们尝试将可靠配置扩展到类路径上会发生什么？

### 一个思维实验

想象模块可以依赖类路径内容，也许在它们的描述符中使用类似 `requires class-path` 的东西。
模块系统可以为这样的依赖项提供什么保证？
事实证明，几乎没有。
只要类路径上至少有一个类，模块系统就必须假设依赖项已满足。
那将不会有太大帮助。
更糟糕的是，它将严重破坏可靠配置，因为你最终可能依赖于 `requires class-path` 的模块。
但它包含的信息极少 - 究竟需要在类路径上放置什么？

将这个假设进一步扩展，想象两个模块 _com.example.framework_ 和 _com.example.library_ 依赖于同一个第三个模块，比如 SLF4J。
一个在SLF4J模块化之前声明了依赖项，因此 `requires class-path`，另一个声明了对模块化SLF4J的依赖，因此 `requires org.slf4j`。
现在，任何依赖 _com.example.framework_ 和 _com.example.library_ 的人会将SLF4J JAR放在哪个路径上？
无论他们选择哪个，模块系统都必须确定两个传递依赖项中的一个未满足。

通过这个思考，我们得出结论，如果你想拥有可靠的模块，依赖任意类路径内容并不是一个好主意。
出于完全相同的原因，没有 `requires class-path`。

### 因此，无名

那么，如何最好地表达最终包含类路径内容的模块不能被依赖呢？
在一个使用名称引用其他模块的模块系统中？
不给予该模块名称，使其成为 _无名_ ，听起来是合理的。
然后你就得到了：
无名模块没有名称，因为没有模块应该在 `requires` 指令中引用它 - 或任何其他指令，就此而言。
没有 `requires`，就没有可读性边缘，没有那个边缘，无名模块中的代码对模块是不可见的。

总结来说，对于显式模块依赖于工件，该工件必须在模块路径上。
这可能意味着你将普通JAR放在模块路径上，这将使它们变成自动模块 - 我们将在下一篇文章中探索的概念。

