# Java模块学习

## 为反射打开模块和包

模块系统的强封装也适用于反射，反射已经失去了其“超级力量”来破坏内部API。

当然，反射是Java生态系统的重要组成部分，因此模块系统有特定的指令来支持反射。
它允许打开包，这使得它们在编译时无法访问，但允许在运行时进行深度反射，并且可以打开整个模块。

**注意**：
要充分利用本文，你需要了解模块系统基础知识。

## 为什么导出包不适用于反射

使类型在模块外部可访问的主要机制是在模块声明中使用`exports`指令导出包含它们的包。
这在反射中不适用，有两个原因：

1. 导出一个包使其成为模块公共API的一部分。
   这邀请其他模块使用它包含的类型，并传达了一定程度的稳定性。
   对于那些处理HTTP请求或与数据库交云的类来说，这通常不是一个很好的选择。
2. 一个更技术性的问题是在导出的包中，只有公共类型的公共成员是可访问的。
   但是依赖于反射的框架经常访问非公共类型、构造函数、访问器或字段，这些仍然会失败。

开放包（和模块）是专门为解决这两点而设计的。

## 为反射打开包

一个模块可以通过在模块声明中添加`opens`指令来为反射《打开一个包》：

```java
module com.example.app {
    opens com.example.entities;
}
```

在编译时，包完全封装，就好像指令不存在一样。
这意味着使用包`com.example.entities`中的类型的模块外部代码_com.example.app_将无法编译。

另一方面，在运行时，包的类型对反射是可用的。
这意味着反射可以自由地与所有类型和成员交云 - 无论是公共的还是非公共的（对于非公共成员，如往常一样使用`AccessibleObject.setAccessible()`）。

你可能已经猜到了，`opens`专门针对反射用例而设计，并且行为与`exports`非常不同：

- 允许访问所有成员，因此不影响你对可见性的决策
- 防止在打开的包中编译代码，并且只允许在运行时访问
- 传达了使用基于反射的框架的意图

如果有必要，一个包可以被导出和打开。

## 打开模块

如果你有一个包含许多需要暴露给反射的包的大型模块，你可能会觉得逐个打开它们很麻烦。
虽然没有像`opens com.example.*`这样的通配符，但有类似的东西存在。
通过在模块声明中的`module`之前放置关键字`open`，可以创建一个《开放模块》：

```java
open module com.example.entities {
    // ...
}
```

一个开放模块打开它包含的所有包，就好像每个包都单独使用了`opens`指令一样。
因此，在开放模块中手动进一步打开包是没有意义的，这也就是为什么在开放模块中的`opens`指令会导致编译错误。

