# 使用自动模块进行增量模块化

模块系统要求一个模块的所有依赖项都位于模块路径（或运行时）上。如果只有模块化JAR在模块路径上有效，那么在项目本身可以变成一个模块之前，项目的所有依赖项都必须是模块，较大的项目将不得不一步到位地进行模块化。为了避免这种自下而上的全生态系统模块化努力以及更大项目的大爆炸式模块化，模块系统还允许在模块路径上的普通JAR，在这里它们变成自动模块。应用了一些特殊规则之后，它们就像所有其他模块一样工作。一条特殊规则是自动模块可以读取无名模块，这使得它们可以作为从模块路径到类路径的桥梁。

**注意**：
为了充分利用本文，你需要了解模块系统基础知识、无名模块和隐式可读性。

## 自动模块

对于模块路径上没有模块描述符的每一个JAR，模块系统都会创建一个*自动模块*。
像任何其他模块一样，它具有三个中心属性：

- 名称：自动模块的名称可以在JAR的清单中通过`Automatic-Module-Name`头定义（下文有更多内容）；如果缺失，模块系统会从文件名生成名称。
- 依赖项：自动模块读取进入图的所有其他模块，包括无名模块。
- 导出：自动模块导出其所有包，并为反射打开它们。

在`META-INF/services`中提供的服务对`ServiceLoader`可用。

自动模块是完全成熟的命名模块，这意味着：

- 它们可以在其他模块的声明中通过名称引用，例如要求它们。
- 即使在Java 9到16上，它们也不受到JDK模块强封装的例外。
- 它们受到像分裂包这样的可靠性检查的约束。

要尝试自动模块，你可以将以下两行代码放入你打包为普通JAR的类中：

```java
String moduleName = this.getClass().getModule().getName();
System.out.println("Module name: " + moduleName);
```

从类路径启动时，输出是`Module name: null`，表明该类最终进入了无名模块。
从模块路径启动时，你会得到预期的`Module name: $JAR`，其中`$JAR`是你给JAR文件的名称。
如果你在清单中添加了一个定义名称的`Automatic-Module-Name`头，当从模块路径启动JAR时你会看到那个名称。
要尝试依赖自动模块，你可以创建第二个项目并在其模块声明中添加`requires $JAR`。

## 自动模块名称 - 小细节，大影响

将普通JAR变成模块的主要目的是能够在模块声明中要求它们。
为此它们需要一个名称，但是缺乏模块描述符，它将从何而来？

### 首先是清单条目，然后是文件名

确定普通JAR模块名称的一种方法依赖于其清单，这是JAR的`META-INF`文件夹中的一个文件`MANIFEST.MF`。
如果模块路径上的JAR不包含描述符，模块系统遵循两步流程来确定自动模块的名称：

1. 它在清单中寻找`Automatic-Module-Name`头。
   如果找到它，它使用相应的值作为模块的名称。
2. 如果清单中没有这个头，模块系统从文件名推断模块名称。

能够从清单推断模块的名称要远远优于其他方式，因为它更稳定 - 下面有更多内容。
从文件名推断模块名称的确切规则有点复杂，但细节并不是特别重要 - 这里是要点：

- JAR文件名通常以版本字符串结尾（如`-2.0.5`）。
   这些被识别并忽略。
- 除了字母和数字之外的每个字符都被变成一个点。

这个过程可能会导致不幸的结果，得到的模块名称无效。
一个例子是字节码操作工具ByteBuddy：
它在Maven Central上发布为`byte-buddy-$VERSION.jar`，这导致自动模块名称为`byte.buddy`（在它定义一个合适的名称之前）。
不幸的是，这是非法的，因为`byte`当然是Java关键字。

### 查找名称

如果你需要找出普通JAR的自动模块名称，你可以对JAR文件运行`jar --describe-module --file $FILE`。
不幸的是，这不会告诉你名称是否来自清单条目还是文件名。
要找出这一点，你有几个选择：

- 使用`jar --file $JAR --extract META-INF/MANIFEST.MF`提取清单并手动查看它。
- 在Linux上，`unzip -p $JAR META-INF/MANIFEST.MF`将清单打印到终端，从而节省你打开文件的时间。
- 重命名文件然后再次运行`jar --describe-module`。

### 何时设置`Automatic-Module-Name`

如果你维护的项目是公开发布的，意味着它的工件可以通过Maven Central或其他公共仓库获得，你应该仔细考虑何时在清单中设置`Automatic-Module-Name`。
正如已经暗示的，它使将你的项目作为自动模块使用更加可靠，但它也带来了承诺，将来，显式模块将是当前JAR的即插即用替代品。
你基本上是在说：“这就是模块将来的样子，我只是还没有发布它们”。

定义自动模块名称让你的用户开始依赖你的项目工件作为模块，有几个重要的影响：

- 未来模块的名称必须与你现在声明的完全相同。
  （否则，可靠的配置会困扰你的用户，因为缺少模块。）
- 工件结构必须保持不变，所以你不能开始将支持的类或包从一个JAR移动到另一个JAR。
  （即使没有模块，这也不推荐实践，但有了类路径，哪个JAR包含一个类并不重要，所以你可以用这种方式蒙混过关。
  另一方面，有了模块系统，一个类的来源就非常重要，因为可访问性迫使用户要求正确的模块。）
- 项目在Java 9及更高版本上运行得相当好。
  如果它需要命令行选项或其他变通方法，这些都有很好的文档记录。
  （否则你不能确定你的代码中是否有隐藏的问题，使得其他承诺变得无足轻重。）

## 自动模块的模块解析

自动模块是从普通JAR创建的，因此它们没有明确依赖项，这引发了它们在解析期间的行为问题。
JAR倾向于彼此依赖，如果模块系统只解析显式要求的自动模块，所有其他自动模块都需要用`--add-modules`添加到图中。
想象一下，对于一个有数百个依赖项的大型项目，你决定将它们全部放在模块路径上。

为了防止这种过度且脆弱的手动模块添加，模块系统一旦遇到显式要求的*第一个*自动模块，就会引入*所有*自动模块。
换句话说，你要么得到所有普通JAR作为自动模块（如果至少有一个是要求或添加的），要么一个也没有（否则）。
另一个方面是自动模块对其他自动模块隐式可读，这意味着任何读取*一个*的模块，读取*全部*自动模块。

如果自动模块只能读取其他命名模块，我们现在就完成了。
一旦你将普通JAR放在模块路径上，它的所有直接依赖项就必须放在模块路径上，然后是它们的依赖项，依此类推，直到所有传递依赖项都被视为模块，显式或自动的。

然而，由于它所暴露的检查（例如分裂包的搜索），将普通JAR变成自动模块可能不起作用。
所以，能够将普通JAR留在类路径上并将其加载到无名模块中将是很好的。
实际上，模块系统通过允许自动模块读取无名模块来实现这一点，这意味着它们的依赖项可以位于类路径_或_模块路径上。

当我们暂时关注平台模块时，我们可以看到自动模块不能表达对它们的依赖。
因此，模块图可能包含也可能不包含它们，如果不包含，自动模块很可能在运行时因缺少类而失败。
唯一的解决办法是项目的维护者非常公开地记录他们需要哪些模块，以便他们的用户可以确保所需的模块存在。
用户可以通过明确要求它们来做到这一点，例如在依赖于自动模块的模块中，或者使用`--add-modules`。

## 依赖自动模块

自动模块的唯一目的是依赖普通JAR，这使得在所有依赖项都模块化之前就可以创建显式模块。
然而，有一个重要的警告：
如果JAR的清单不包含`Automatic-Module-Name`条目，自动模块名称是从文件名推断出来的。

但是，根据其设置，不同的项目可能对相同的JAR使用不同的名称。
此外，大多数项目使用基于Maven的本地仓库，其中JAR文件被命名为`${artifactID}-$VERSION`，从中模块系统很可能会推断出_`${artifactID} `_作为自动模块的名称。
这是有问题的，因为工件ID通常不遵循反向域名命名约定，这意味着一旦项目变得模块化，模块名称很可能会发生改变。

总而言之，相同的JAR在不同的项目中（取决于它们的设置）以及在不同的时间（模块化之前和之后）可能会得到不同的模块名称。
这有可能在下游造成混乱，必须不惜一切代价避免！

看起来好像犯严重错误是因为根据文件名基于模块名称要求普通JAR。
但情况并非总是如此 - 使用这种方法对于应用程序和其他场景是完全没问题的，开发者可以完全控制要求此类自动模块的模块描述符。
不，错误在于将具有此类依赖项的模块*发布*到公共仓库。
只有这样，用户才会陷入一个模块隐式依赖于他们无法控制的细节，可能会导致额外的工作甚至无法解决的分歧。

因此，你绝不应该发布（到公共仓库）具有自动模块名称的显式模块。
相反，你应该：

- 确保在清单中设置`Automatic-Module-Name`。
- 确保该名称与显式模块的名称完全相同。
- 确保你的项目在Java 9及更高版本上运行得相当好。

